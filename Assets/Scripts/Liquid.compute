struct Speck
{
	float3 Pos;
	float3 Vel;
};

RWStructuredBuffer<Speck> Specks;
RWStructuredBuffer<Speck> SortedSpecks;
RWStructuredBuffer<uint> PartCounts;
RWStructuredBuffer<uint2> PartIndices;
RWStructuredBuffer<int> PartIndicesX;
RWStructuredBuffer<int> PartIndicesY;

RWStructuredBuffer<uint> PfxSumA;
RWStructuredBuffer<uint> PfxSumB;
uint PfxSumPower;

float K;
float A;
float B;
float C;
float D;
float E;
float F;

uint NumSpecks;
float SpeckRadius;
float Damper;
float MaxVel;
float MaxDist;
float Bounds;
uint PartsPerDim;
uint NumParts;
float BoundsForce;
float Multiplier;
float DeltaTime;

// Boundary conditions
float KBoundary;
float Phase;
float Amplitude;
float Wavelength;
float Restitution;

float3 Gravity;

float Attraction(float x)
{
	return C * exp((x + E) / -D);
}

float Repulsion(float x)
{
	return A * exp((x + F) / -B);
}

float3 ProjectOnPlane(float3 vec, float3 normal)
{
    return vec - (normal * dot(vec, normal));
}

void ClampInBounds(float3 axis, uint id)
{
	Speck speck = Specks[id];

	float pos = dot(speck.Pos, axis);
	float s = sign(pos);
	float mag = abs(pos);
	if (mag > Bounds / 2)
	{
		float3 position = Specks[id].Pos;
		Specks[id].Pos = ProjectOnPlane(position, axis) + (axis * (Bounds / 2) * s);

		float velAlongAxis = dot(Specks[id].Vel, axis);
		float sv = sign(velAlongAxis);

		if (s * velAlongAxis > 0)
		{
			Specks[id].Vel = ProjectOnPlane(Specks[id].Vel, axis) + (axis * -velAlongAxis * Restitution);
		}
	}
}

uint3 GetPartCoords(float3 pos)
{
	pos += float3(1, 1, 1) * (Bounds / 2);
	pos /= MaxDist;
	return ceil(pos) - 1;
}

uint GetPartitionIdx(float3 pos)
{
	uint3 coords = GetPartCoords(pos);
	return coords.x + (coords.y * PartsPerDim) + (coords.z * PartsPerDim * PartsPerDim);
}

float3 CalculateBoundaryForce(float3 pos)
{
	float limit = Bounds / 2;
	float3 wave = sin((pos + Phase) / Wavelength) * Amplitude;

	float3 plusDist = abs(clamp(pos, -limit, limit) - limit) - wave;
	float3 negDist = abs(clamp(pos, -limit, limit) + limit) - wave;

	float3 pSq = plusDist * plusDist;
	float3 nSq = negDist * negDist;

	return (KBoundary / nSq) - (KBoundary / pSq);
}

#pragma kernel UpdateVelocities
[numthreads(256, 1, 1)]
void UpdateVelocities (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= NumSpecks)
		return;

	float3 force = float3(0, 0, 0);
	Speck thisSpeck = Specks[id.x];

	uint partIdx = PartIndices[id.x].x;
	uint subPartIdx = PartIndices[id.x].y;
	int partOffset = PfxSumB[partIdx] - PartCounts[partIdx];
	uint sortedIdx = partOffset + subPartIdx;

	uint partsPerPlane = PartsPerDim * PartsPerDim;

	int3 partCoords = GetPartCoords(thisSpeck.Pos);

	int xMid = partIdx % PartsPerDim;
	int yMid = (partIdx / PartsPerDim) % PartsPerDim;
	int zMid = (partIdx / partsPerPlane);

	for	(int z = zMid - 1; z <= zMid + 1; z++)
	{
		for	(int y = yMid - 1; y <= yMid + 1; y++)
		{
			for	(int x = xMid - 1; x <= xMid + 1; x++)
			{
				uint partIdx = (partsPerPlane * z) + (PartsPerDim * y) + x;
				uint partStart = PfxSumB[partIdx] - PartCounts[partIdx];
				uint partEnd = PfxSumB[partIdx];

				for	(uint i = partStart; i < partEnd; i++)
				{
					Speck otherSpeck = SortedSpecks[i];

					float dist = distance(thisSpeck.Pos, otherSpeck.Pos);

					if (isnan(dist) || i == sortedIdx || dist > MaxDist)
						continue;

					float forceMag = Attraction(dist) - Repulsion(dist);
					float3 toOther = normalize(otherSpeck.Pos - thisSpeck.Pos);

					if (dist == 0)
					{
						toOther = normalize(thisSpeck.Pos) * (-1 * (sortedIdx < i));
					}

					force += forceMag * toOther;
				}
			}
		}
	}

	float3 a = (force * Multiplier) + Gravity;
	a += CalculateBoundaryForce(Specks[id.x].Pos);
	Specks[id.x].Vel += a * DeltaTime;
	Specks[id.x].Vel *= 1 - Damper;

	if (length(Specks[id.x].Vel) > MaxVel)
	{
		Specks[id.x].Vel = normalize(Specks[id.x].Vel) * MaxVel;
	}
}

#pragma kernel UpdatePositions
[numthreads(256, 1, 1)]
void UpdatePositions (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= NumSpecks)
		return;

	Specks[id.x].Pos += Specks[id.x].Vel * DeltaTime;
	ClampInBounds(float3(1, 0, 0), id.x);
	ClampInBounds(float3(0, 1, 0), id.x);
	ClampInBounds(float3(0, 0, 1), id.x);
}

#pragma kernel PopulatePartitions
[numthreads(256, 1, 1)]
void PopulatePartitions (uint id : SV_DispatchThreadID)
{
	if (id.x >= NumSpecks)
		return;

	uint partIdx = GetPartitionIdx(Specks[id.x].Pos);
	PartIndices[id.x].x = partIdx;
	InterlockedAdd(PartCounts[partIdx], 1, PartIndices[id.x].y);
	InterlockedAdd(PfxSumA[partIdx], 1);
}

#pragma kernel SumPartCounts
[numthreads(256, 1, 1)]
void SumPartCounts (uint id : SV_DispatchThreadID)
{
	if (id.x >= NumParts)
		return;

	PfxSumB[id.x] = PfxSumA[id.x] + ((id.x >= PfxSumPower) * PfxSumA[id.x - PfxSumPower]);
}

#pragma kernel ClearBuffers
[numthreads(256, 1, 1)]
void ClearBuffers (uint id : SV_DispatchThreadID)
{
	if (id.x >= NumParts)
		return;

	PartCounts[id.x] = 0;
	PfxSumA[id.x] = 0;
	PfxSumB[id.x] = 0;
}

#pragma kernel SortSpecks
[numthreads(256, 1, 1)]
void SortSpecks (uint id : SV_DispatchThreadID)
{
	if (id.x >= NumSpecks)
		return;

	int partIdx = PartIndices[id.x].x;
	int subPartIdx = PartIndices[id.x].y;
	int partOffset = PfxSumB[partIdx] - PartCounts[partIdx];

	int globalIdx = partOffset + subPartIdx;
	SortedSpecks[globalIdx] = Specks[id.x];
}
