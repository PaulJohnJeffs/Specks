struct Speck
{
	float3 Pos;
	float3 LastPos;
	float3 Vel;
};

RWStructuredBuffer<Speck> Specks;
RWStructuredBuffer<Speck> SortedSpecks;
RWStructuredBuffer<uint> PartCounts;
RWStructuredBuffer<uint2> PartIndices;
RWStructuredBuffer<int> PartIndicesX;
RWStructuredBuffer<int> PartIndicesY;

RWStructuredBuffer<uint> PfxSumA;
RWStructuredBuffer<uint> PfxSumB;
uint PfxSumPower;

float K;
float A;
float B;
float C;
float D;
float E;
float F;

uint NumSpecks;
float SpeckRadius;
float Damper;
float MaxVel;
float MaxDist;
float Bounds;
uint PartsPerDim;
uint NumParts;
float BoundsForce;
float Multiplier;
float LastDeltaTime;
float DeltaTime;
float FloatMin;

// Boundary conditions
float KBoundary;
float Phase;
float Amplitude;
float Wavelength;
float Restitution;

float3 Gravity;

float Attraction(float x)
{
	float rt = (B * x) - C;
	return (K * A) / (rt * rt);
}

float Repulsion(float x)
{
	float rt = (F * x) - E;
	return (K * D) / (rt * rt);
}

float3 ProjectOnPlane(float3 vec, float3 normal)
{
    return vec - (normal * dot(vec, normal));
}

void ClampInBounds(float3 axis, uint id)
{
	Speck speck = Specks[id];
	float3 pos = Specks[id].Pos;
	float wave = sin((((pos.x + pos.z) / 2) + Phase) / Wavelength) * Amplitude;
	
	float posDot = dot(pos + float3(0, wave, 0), axis);
	float s = sign(posDot);
	float mag = abs(posDot);
	if (mag > Bounds / 2)
	{
		Specks[id].Pos = ProjectOnPlane(Specks[id].Pos, axis) + (axis * ((Bounds / 2) + float3(0, wave, 0)) * s);

		float velAlongAxis = dot(Specks[id].Vel, axis);
		float sv = sign(velAlongAxis);

		if (s * velAlongAxis > 0)
		{
			Specks[id].Vel = ProjectOnPlane(Specks[id].Vel, axis) + (axis * -velAlongAxis * Restitution);
		}
	}
}

uint3 GetPartCoords(float3 pos)
{
	pos += float3(1, 1, 1) * (Bounds / 2);
	pos /= MaxDist;
	return ceil(pos) - 1;
}

uint GetPartitionIdx(float3 pos)
{
	uint3 coords = GetPartCoords(pos);
	return coords.x + (coords.y * PartsPerDim) + (coords.z * PartsPerDim * PartsPerDim);
}

float3 CalculateBoundaryForce(int id)
{
	//float limit = Bounds / 2;
	//float3 p0 = Specks[id].Pos;
	//float3 p1 = Specks[id].LastPos;

	//float3 plus0 = abs(p0 - limit);
	//float3 plus1 = abs(p1 - limit);

	//float min0 = abs(p0 + limit);
	//float min1 = abs(p1 + limit);

	//float3 plusForce = KBoundary * ( (1 / min(plus0, plus1)) - (1 / max(plus0, plus1)) );
	//float3 minForce = KBoundary * ( (1 / min(min0, min1)) - (1 / max(min0, min1)) );

	//return minForce - plusForce;

	float3 pos = Specks[id].Pos;

	float limit = Bounds / 2;
	//float wave = sin((((pos.x + pos.z) / 2) + Phase) / Wavelength) * Amplitude;

	//float3 plusDist = max((-pos + limit) - wave, 0.001);// - wave;
	float3 plusDist = max((-pos + limit), 0.001);// - wave;
	//float3 negDist = max((pos + limit) - wave, 0.001);// - wave;
	float3 negDist = max((pos + limit), 0.001);// - wave;

	float3 pSq = plusDist * plusDist;
	float3 nSq = negDist * negDist;

	return (KBoundary / nSq) - (KBoundary / pSq);
}

#pragma kernel UpdateVelocities
[numthreads(256, 1, 1)]
void UpdateVelocities (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= NumSpecks)
		return;

	float3 force = float3(0, 0, 0);
	Speck thisSpeck = Specks[id.x];

	uint partIdx = PartIndices[id.x].x;
	uint subPartIdx = PartIndices[id.x].y;
	int partOffset = PfxSumB[partIdx] - PartCounts[partIdx];
	uint sortedIdx = partOffset + subPartIdx;

	uint partsPerPlane = PartsPerDim * PartsPerDim;

	int3 partCoords = GetPartCoords(thisSpeck.Pos);

	int xMid = partIdx % PartsPerDim;
	int yMid = (partIdx / PartsPerDim) % PartsPerDim;
	int zMid = (partIdx / partsPerPlane);

	for	(int z = zMid - 1; z <= zMid + 1; z++)
	{
		for	(int y = yMid - 1; y <= yMid + 1; y++)
		{
			for	(int x = xMid - 1; x <= xMid + 1; x++)
			{
				uint partIdx = (partsPerPlane * z) + (PartsPerDim * y) + x;
				uint partStart = PfxSumB[partIdx] - PartCounts[partIdx];
				uint partEnd = PfxSumB[partIdx];

				for	(uint i = partStart; i < partEnd; i++)
				{
					Speck otherSpeck = SortedSpecks[i];

					float dist = distance(thisSpeck.Pos, otherSpeck.Pos);

					if (isnan(dist) || i == sortedIdx || dist > MaxDist)
						continue;

					float forceMag = Attraction(dist) - Repulsion(dist);
					float3 toOther = normalize(otherSpeck.Pos - thisSpeck.Pos);

					if (dist == 0)
					{
						toOther = normalize(thisSpeck.Pos) * (-1 * (sortedIdx < i));
					}

					force += forceMag * toOther;
				}
			}
		}
	}

	float3 a = (force * Multiplier) + Gravity;
	a += CalculateBoundaryForce(id.x);
	float3 velBefore = Specks[id.x].Vel;
	Specks[id.x].Vel += a * DeltaTime;
	float velDot = dot(velBefore, Specks[id.x].Vel);

	//if (velDot < 0)
	//{
	//	// particle has changed direction as a result of a collision with another particle.
	//	float magBefore = length(velBefore);
	//	if (length(Specks[id.x].Vel) > magBefore)
	//	{
	//		Specks[id.x].Vel = normalize(Specks[id.x].Vel) * magBefore;
	//	}
	//}

	Specks[id.x].Vel *= 1 - Damper;

	if (length(Specks[id.x].Vel) > MaxVel)
	{
		Specks[id.x].Vel = normalize(Specks[id.x].Vel) * MaxVel;
	}
}

#pragma kernel UpdatePositions
[numthreads(256, 1, 1)]
void UpdatePositions (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= NumSpecks)
		return;

	Specks[id.x].LastPos = Specks[id.x].Pos;
	Specks[id.x].Pos += Specks[id.x].Vel * DeltaTime;

	//ClampInBounds(float3(1, 0, 0), id.x);
	//ClampInBounds(float3(0, 1, 0), id.x);
	//ClampInBounds(float3(0, 0, 1), id.x);
}

#pragma kernel PopulatePartitions
[numthreads(256, 1, 1)]
void PopulatePartitions (uint id : SV_DispatchThreadID)
{
	if (id.x >= NumSpecks)
		return;

	uint partIdx = GetPartitionIdx(Specks[id.x].Pos);
	PartIndices[id.x].x = partIdx;
	InterlockedAdd(PartCounts[partIdx], 1, PartIndices[id.x].y);
	InterlockedAdd(PfxSumA[partIdx], 1);
}

#pragma kernel SumPartCounts
[numthreads(256, 1, 1)]
void SumPartCounts (uint id : SV_DispatchThreadID)
{
	if (id.x >= NumParts)
		return;

	PfxSumB[id.x] = PfxSumA[id.x] + ((id.x >= PfxSumPower) * PfxSumA[id.x - PfxSumPower]);
}

#pragma kernel ClearBuffers
[numthreads(256, 1, 1)]
void ClearBuffers (uint id : SV_DispatchThreadID)
{
	if (id.x >= NumParts)
		return;

	PartCounts[id.x] = 0;
	PfxSumA[id.x] = 0;
	PfxSumB[id.x] = 0;
}

#pragma kernel SortSpecks
[numthreads(256, 1, 1)]
void SortSpecks (uint id : SV_DispatchThreadID)
{
	if (id.x >= NumSpecks)
		return;

	int partIdx = PartIndices[id.x].x;
	int subPartIdx = PartIndices[id.x].y;
	int partOffset = PfxSumB[partIdx] - PartCounts[partIdx];

	int globalIdx = partOffset + subPartIdx;
	SortedSpecks[globalIdx] = Specks[id.x];
}
