struct Speck
{
	float3 Pos;
	float3 Vel;
};

RWStructuredBuffer<Speck> Specks;
RWStructuredBuffer<Speck> SortedSpecks;

float A;
float B;
float C;
float D;
float E;
float F;

uint NumSpecks;
float SpeckRadius;
float Damper;
float MaxVel;
float MaxDist;
float Bounds;
float BoundsForce;
float Multiplier;
float DeltaTime;

float3 Gravity;

float Attraction(float x)
{
	return C * exp((x + E) / -D);
}

float Repulsion(float x)
{
	return A * exp((x + F) / -B);
}

float3 ProjectOnPlane(float3 vec, float3 normal)
{
    return vec - (normal * dot(vec, normal));
}

void ClampInBounds(float3 axis, uint id)
{
	Speck speck = Specks[id];

	float pos = dot(speck.Pos, axis);
	float s = sign(pos);
	float mag = abs(pos);
	if (mag > Bounds / 2)
	{
		float3 position = Specks[id].Pos;
		Specks[id].Pos = ProjectOnPlane(position, axis) + (axis * (Bounds / 2) * s);

		if (s * dot(Specks[id].Vel, axis) > 0)
		{
			Specks[id].Vel = ProjectOnPlane(Specks[id].Vel, axis);
		}

		//Specks[id].Pos *= 0.99;
	}
}

#pragma kernel UpdateVelocities
[numthreads(256, 1, 1)]
void UpdateVelocities (uint3 id : SV_DispatchThreadID)
{
	float3 force = float3(0, 0, 0);
	Speck thisSpeck = Specks[id.x];
	for (uint i = 0; i < NumSpecks; i++)
	{
		Speck otherSpeck = Specks[i];

		if (id.x == i || distance(thisSpeck.Pos, otherSpeck.Pos) > MaxDist)
			continue;

		//float x = max(0, distance(thisSpeck.Pos, otherSpeck.Pos);// - SpeckRadius);
		float x = distance(thisSpeck.Pos, otherSpeck.Pos);// - SpeckRadius);
		float forceMag = Attraction(x) - Repulsion(x);
		float3 toOther = normalize(otherSpeck.Pos - thisSpeck.Pos);

		if (distance(thisSpeck.Pos, otherSpeck.Pos) == 0)
		{
			toOther = normalize(thisSpeck.Pos) * (-1 * (id.x < i));
		}

		force += forceMag * toOther;
	}

	float3 a = (force * Multiplier) + Gravity;
	Specks[id.x].Vel += a * DeltaTime;
	Specks[id.x].Vel *= 1 - Damper;
	//if (isnan(length(Specks[id.x].Vel)))
	//{
	//	Specks[id.x].Vel = float3(0, 0, 0);
	//}

	if (length(Specks[id.x].Vel) > MaxVel)
	{
		Specks[id.x].Vel = normalize(Specks[id.x].Vel) * MaxVel;
	}
}

#pragma kernel UpdatePositions
[numthreads(256, 1, 1)]
void UpdatePositions (uint3 id : SV_DispatchThreadID)
{
	Specks[id.x].Pos += Specks[id.x].Vel * DeltaTime;
	//
	//float3 p = Specks[id.x].Pos;

	//if (p.y < 0)
	//{
	//	Specks[id.x].Pos.y = 0;
	//	Specks[id.x].Vel.y = max(0, Specks[id.x].Vel.y);
	//}

	//if (p.x < -Bounds / 2)
	//{
	//	float k = p.x + (Bounds / 2);
	//	k = max(0, k);
	//	force += float3(BoundsForce, 0, 0) * Repulsion(k);
	//}
	//else if (p.x > Bounds / 2)
	//{
	//	float k = (Bounds / 2) - p.x;
	//	k = max(0, k);
	//	force += float3(-BoundsForce, 0, 0) * Repulsion(k);
	//}

	//if (p.z < -Bounds / 2)
	//{
	//	float k = p.z + (Bounds / 2);
	//	k = max(0, k);
	//	force += float3(0, 0, BoundsForce) * Repulsion(k);
	//	//Specks[id.x].Vel.z *= -0.5;
	//}
	//else if (p.z > Bounds / 2)
	//{
	//	float k = (Bounds / 2) - p.z;
	//	k = max(0, k);
	//	force += float3(0, 0, -BoundsForce) * Repulsion(k);
	//}

	//if (Specks[id.x].Pos.y <= 0)
	//{
	//	Specks[id.x].Pos.y = 0;
	//	Specks[id.x].Vel.y = 0;
	//}

	ClampInBounds(float3(1, 0, 0), id.x);
	ClampInBounds(float3(0, 1, 0), id.x);
	ClampInBounds(float3(0, 0, 1), id.x);
}
